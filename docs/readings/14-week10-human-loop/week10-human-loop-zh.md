# ç¬¬10å‘¨ï¼šäººæœºåä½œ

> ç¬¬äº”é˜¶æ®µï¼šé«˜çº§ä¸»é¢˜
> ç¬¬10å‘¨å­¦ä¹ ææ–™ï¼šç¡®è®¤æ¨¡å¼ã€å®¡æ‰¹å·¥ä½œæµä¸å‡çº§å¤„ç†

---

## ç¬¬1-2å¤©ï¼šäººæœºåä½œåŸºç¡€

### 1. ä¸ºä»€ä¹ˆéœ€è¦äººæœºåä½œï¼Ÿ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      äººæœºåä½œåœºæ™¯                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   é«˜é£é™©       â”‚    â”‚    æ¨¡ç³Š        â”‚    â”‚    æ•æ„Ÿ        â”‚ â”‚
â”‚  â”‚   æ“ä½œ         â”‚    â”‚    è¯·æ±‚        â”‚    â”‚    æ“ä½œ        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   è´¢åŠ¡         â”‚    â”‚    ç­–ç•¥        â”‚    â”‚    å¯¹å¤–        â”‚ â”‚
â”‚  â”‚   å†³ç­–         â”‚    â”‚    ä¾‹å¤–        â”‚    â”‚    æ²Ÿé€š        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. ç¡®è®¤è¯·æ±‚æ¨¡å‹

```csharp
namespace DawningAgents.Core.HumanLoop;

/// <summary>
/// äººå·¥ç¡®è®¤è¯·æ±‚
/// </summary>
public record ConfirmationRequest
{
    /// <summary>
    /// å”¯ä¸€è¯·æ±‚æ ‡è¯†ç¬¦
    /// </summary>
    public string Id { get; init; } = Guid.NewGuid().ToString();
    
    /// <summary>
    /// éœ€è¦çš„ç¡®è®¤ç±»å‹
    /// </summary>
    public ConfirmationType Type { get; init; }
    
    /// <summary>
    /// éœ€è¦ç¡®è®¤çš„æ“ä½œ
    /// </summary>
    public required string Action { get; init; }
    
    /// <summary>
    /// è¯¦ç»†æè¿°
    /// </summary>
    public required string Description { get; init; }
    
    /// <summary>
    /// æ“ä½œçš„é£é™©çº§åˆ«
    /// </summary>
    public RiskLevel RiskLevel { get; init; } = RiskLevel.Medium;
    
    /// <summary>
    /// ä¾›äººç±»é€‰æ‹©çš„é€‰é¡¹
    /// </summary>
    public IReadOnlyList<ConfirmationOption> Options { get; init; } = [];
    
    /// <summary>
    /// ç”¨äºå†³ç­–çš„ä¸Šä¸‹æ–‡æ•°æ®
    /// </summary>
    public IDictionary<string, object> Context { get; init; } = new Dictionary<string, object>();
    
    /// <summary>
    /// è¯·æ±‚åˆ›å»ºæ—¶é—´
    /// </summary>
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;
    
    /// <summary>
    /// ç¡®è®¤è¶…æ—¶æ—¶é—´
    /// </summary>
    public TimeSpan? Timeout { get; init; }
    
    /// <summary>
    /// è¶…æ—¶æ—¶çš„é»˜è®¤æ“ä½œ
    /// </summary>
    public string? DefaultOnTimeout { get; init; }
}

public enum ConfirmationType
{
    Binary,          // æ˜¯/å¦
    MultiChoice,     // å¤šé€‰é¡¹
    FreeformInput,   // ç”¨æˆ·è¾“å…¥
    Review           // å®¡æŸ¥å’Œä¿®æ”¹
}

public enum RiskLevel
{
    Low,       // ä½é£é™©
    Medium,    // ä¸­ç­‰é£é™©
    High,      // é«˜é£é™©
    Critical   // å…³é”®é£é™©
}

public record ConfirmationOption
{
    public required string Id { get; init; }
    public required string Label { get; init; }
    public string? Description { get; init; }
    public bool IsDefault { get; init; }
    public bool IsDangerous { get; init; }
}

/// <summary>
/// äººå·¥å“åº”
/// </summary>
public record ConfirmationResponse
{
    public required string RequestId { get; init; }
    public required string SelectedOption { get; init; }
    public string? FreeformInput { get; init; }
    public string? ModifiedContent { get; init; }
    public DateTime RespondedAt { get; init; } = DateTime.UtcNow;
    public string? RespondedBy { get; init; }
    public string? Reason { get; init; }
}
```

### 3. äººæœºäº¤äº’å¤„ç†å™¨æ¥å£

```csharp
namespace DawningAgents.Core.HumanLoop;

/// <summary>
/// äººæœºäº¤äº’æ¥å£
/// </summary>
public interface IHumanInteractionHandler
{
    /// <summary>
    /// è¯·æ±‚äººå·¥ç¡®è®¤
    /// </summary>
    Task<ConfirmationResponse> RequestConfirmationAsync(
        ConfirmationRequest request,
        CancellationToken cancellationToken = default);
    
    /// <summary>
    /// è¯·æ±‚äººå·¥è¾“å…¥/åé¦ˆ
    /// </summary>
    Task<string> RequestInputAsync(
        string prompt,
        string? defaultValue = null,
        CancellationToken cancellationToken = default);
    
    /// <summary>
    /// é€šçŸ¥äººç±»ï¼ˆæ— éœ€å“åº”ï¼‰
    /// </summary>
    Task NotifyAsync(
        string message,
        NotificationLevel level = NotificationLevel.Info,
        CancellationToken cancellationToken = default);
    
    /// <summary>
    /// å‡çº§åˆ°äººå·¥å¤„ç†
    /// </summary>
    Task<EscalationResult> EscalateAsync(
        EscalationRequest request,
        CancellationToken cancellationToken = default);
}

public enum NotificationLevel
{
    Info,     // ä¿¡æ¯
    Warning,  // è­¦å‘Š
    Error,    // é”™è¯¯
    Success   // æˆåŠŸ
}
```

---

## ç¬¬3-4å¤©ï¼šç¡®è®¤æ¨¡å¼

### 1. æ§åˆ¶å°äº¤äº’å¤„ç†å™¨

```csharp
namespace DawningAgents.Core.HumanLoop.Handlers;

using Microsoft.Extensions.Logging;

/// <summary>
/// åŸºäºæ§åˆ¶å°çš„äººæœºäº¤äº’
/// </summary>
public class ConsoleInteractionHandler : IHumanInteractionHandler
{
    private readonly ILogger<ConsoleInteractionHandler> _logger;

    public ConsoleInteractionHandler(ILogger<ConsoleInteractionHandler> logger)
    {
        _logger = logger;
    }

    public async Task<ConfirmationResponse> RequestConfirmationAsync(
        ConfirmationRequest request,
        CancellationToken cancellationToken = default)
    {
        Console.WriteLine();
        Console.WriteLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        Console.WriteLine($"ğŸ”” éœ€è¦ç¡®è®¤ ({request.RiskLevel})");
        Console.WriteLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        Console.WriteLine($"æ“ä½œï¼š{request.Action}");
        Console.WriteLine($"æè¿°ï¼š{request.Description}");
        Console.WriteLine();

        if (request.Context.Count > 0)
        {
            Console.WriteLine("ä¸Šä¸‹æ–‡ï¼š");
            foreach (var (key, value) in request.Context)
            {
                Console.WriteLine($"  {key}ï¼š{value}");
            }
            Console.WriteLine();
        }

        string selectedOption;

        switch (request.Type)
        {
            case ConfirmationType.Binary:
                selectedOption = await GetBinaryConfirmation(cancellationToken);
                break;
                
            case ConfirmationType.MultiChoice:
                selectedOption = await GetMultiChoiceConfirmation(request.Options, cancellationToken);
                break;
                
            case ConfirmationType.FreeformInput:
                var input = await GetFreeformInput(cancellationToken);
                return new ConfirmationResponse
                {
                    RequestId = request.Id,
                    SelectedOption = "input",
                    FreeformInput = input
                };
                
            default:
                selectedOption = "unknown";
                break;
        }

        return new ConfirmationResponse
        {
            RequestId = request.Id,
            SelectedOption = selectedOption
        };
    }

    public Task<string> RequestInputAsync(
        string prompt,
        string? defaultValue = null,
        CancellationToken cancellationToken = default)
    {
        Console.WriteLine();
        Console.Write($"ğŸ“ {prompt}");
        if (defaultValue != null)
        {
            Console.Write($" [{defaultValue}]");
        }
        Console.Write("ï¼š");
        
        var input = Console.ReadLine();
        return Task.FromResult(string.IsNullOrWhiteSpace(input) ? (defaultValue ?? "") : input);
    }

    public Task NotifyAsync(
        string message,
        NotificationLevel level = NotificationLevel.Info,
        CancellationToken cancellationToken = default)
    {
        var icon = level switch
        {
            NotificationLevel.Info => "â„¹ï¸",
            NotificationLevel.Warning => "âš ï¸",
            NotificationLevel.Error => "âŒ",
            NotificationLevel.Success => "âœ…",
            _ => "ğŸ“¢"
        };

        Console.WriteLine($"{icon} {message}");
        return Task.CompletedTask;
    }

    public async Task<EscalationResult> EscalateAsync(
        EscalationRequest request,
        CancellationToken cancellationToken = default)
    {
        Console.WriteLine();
        Console.WriteLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        Console.WriteLine($"ğŸš¨ éœ€è¦å‡çº§å¤„ç† ({request.Severity})");
        Console.WriteLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        Console.WriteLine($"åŸå› ï¼š{request.Reason}");
        Console.WriteLine($"æè¿°ï¼š{request.Description}");
        Console.WriteLine();

        Console.WriteLine("å¯ç”¨æ“ä½œï¼š");
        Console.WriteLine("  1. è§£å†³ - æä¾›è§£å†³æ–¹æ¡ˆ");
        Console.WriteLine("  2. è·³è¿‡ - è·³è¿‡æ­¤æ“ä½œ");
        Console.WriteLine("  3. ä¸­æ­¢ - ä¸­æ­¢æ•´ä¸ªæ“ä½œ");
        Console.WriteLine();

        Console.Write("é€‰æ‹©æ“ä½œ (1/2/3)ï¼š");
        var choice = Console.ReadLine()?.Trim();

        return choice switch
        {
            "1" => new EscalationResult
            {
                RequestId = request.Id,
                Action = EscalationAction.Resolved,
                Resolution = await RequestInputAsync("è¾“å…¥è§£å†³æ–¹æ¡ˆ", cancellationToken: cancellationToken)
            },
            "2" => new EscalationResult
            {
                RequestId = request.Id,
                Action = EscalationAction.Skipped
            },
            _ => new EscalationResult
            {
                RequestId = request.Id,
                Action = EscalationAction.Aborted
            }
        };
    }

    private Task<string> GetBinaryConfirmation(CancellationToken cancellationToken)
    {
        Console.Write("ç»§ç»­ï¼Ÿ(y/n)ï¼š");
        var input = Console.ReadLine()?.Trim().ToLower();
        return Task.FromResult(input == "y" || input == "yes" ? "yes" : "no");
    }

    private Task<string> GetMultiChoiceConfirmation(
        IReadOnlyList<ConfirmationOption> options,
        CancellationToken cancellationToken)
    {
        Console.WriteLine("é€‰é¡¹ï¼š");
        for (int i = 0; i < options.Count; i++)
        {
            var opt = options[i];
            var marker = opt.IsDefault ? "*" : " ";
            var danger = opt.IsDangerous ? " âš ï¸" : "";
            Console.WriteLine($"  {marker}{i + 1}. {opt.Label}{danger}");
            if (!string.IsNullOrEmpty(opt.Description))
            {
                Console.WriteLine($"      {opt.Description}");
            }
        }
        Console.WriteLine();

        Console.Write("é€‰æ‹©é€‰é¡¹ï¼š");
        var input = Console.ReadLine()?.Trim();
        
        if (int.TryParse(input, out var index) && index > 0 && index <= options.Count)
        {
            return Task.FromResult(options[index - 1].Id);
        }

        // è¿”å›é»˜è®¤é€‰é¡¹
        var defaultOpt = options.FirstOrDefault(o => o.IsDefault);
        return Task.FromResult(defaultOpt?.Id ?? options[0].Id);
    }

    private Task<string> GetFreeformInput(CancellationToken cancellationToken)
    {
        Console.Write("è¾“å…¥æ‚¨çš„å†…å®¹ï¼š");
        return Task.FromResult(Console.ReadLine() ?? "");
    }
}
```

### 2. å¼‚æ­¥å›è°ƒå¤„ç†å™¨

```csharp
namespace DawningAgents.Core.HumanLoop.Handlers;

using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;

/// <summary>
/// ç”¨äºWeb/APIäº¤äº’çš„å¼‚æ­¥å¤„ç†å™¨
/// </summary>
public class AsyncCallbackHandler : IHumanInteractionHandler
{
    private readonly ConcurrentDictionary<string, TaskCompletionSource<ConfirmationResponse>> _pendingConfirmations = new();
    private readonly ConcurrentDictionary<string, TaskCompletionSource<EscalationResult>> _pendingEscalations = new();
    private readonly ILogger<AsyncCallbackHandler> _logger;

    public event EventHandler<ConfirmationRequest>? ConfirmationRequested;
    public event EventHandler<EscalationRequest>? EscalationRequested;
    public event EventHandler<(string Message, NotificationLevel Level)>? NotificationSent;

    public AsyncCallbackHandler(ILogger<AsyncCallbackHandler> logger)
    {
        _logger = logger;
    }

    public async Task<ConfirmationResponse> RequestConfirmationAsync(
        ConfirmationRequest request,
        CancellationToken cancellationToken = default)
    {
        var tcs = new TaskCompletionSource<ConfirmationResponse>();
        _pendingConfirmations[request.Id] = tcs;

        // è§¦å‘äº‹ä»¶ä¾›UIå¤„ç†
        ConfirmationRequested?.Invoke(this, request);

        try
        {
            // ç­‰å¾…å“åº”ï¼Œæ”¯æŒè¶…æ—¶
            if (request.Timeout.HasValue)
            {
                using var cts = new CancellationTokenSource(request.Timeout.Value);
                using var linked = CancellationTokenSource.CreateLinkedTokenSource(cts.Token, cancellationToken);
                
                var completedTask = await Task.WhenAny(tcs.Task, Task.Delay(-1, linked.Token));
                if (completedTask != tcs.Task)
                {
                    // è¶…æ—¶ - è¿”å›é»˜è®¤å€¼
                    return new ConfirmationResponse
                    {
                        RequestId = request.Id,
                        SelectedOption = request.DefaultOnTimeout ?? "timeout"
                    };
                }
            }

            return await tcs.Task;
        }
        finally
        {
            _pendingConfirmations.TryRemove(request.Id, out _);
        }
    }

    /// <summary>
    /// å®ŒæˆæŒ‚èµ·çš„ç¡®è®¤ï¼ˆç”±UI/APIè°ƒç”¨ï¼‰
    /// </summary>
    public void CompleteConfirmation(ConfirmationResponse response)
    {
        if (_pendingConfirmations.TryGetValue(response.RequestId, out var tcs))
        {
            tcs.TrySetResult(response);
        }
    }

    public Task<string> RequestInputAsync(
        string prompt,
        string? defaultValue = null,
        CancellationToken cancellationToken = default)
    {
        var request = new ConfirmationRequest
        {
            Type = ConfirmationType.FreeformInput,
            Action = "input",
            Description = prompt,
            Context = new Dictionary<string, object>
            {
                ["defaultValue"] = defaultValue ?? ""
            }
        };

        var tcs = new TaskCompletionSource<string>();
        _pendingConfirmations[request.Id] = new TaskCompletionSource<ConfirmationResponse>();
        
        // å®Œæˆæ—¶è½¬æ¢
        _pendingConfirmations[request.Id].Task.ContinueWith(t =>
        {
            tcs.TrySetResult(t.Result.FreeformInput ?? defaultValue ?? "");
        }, cancellationToken);

        ConfirmationRequested?.Invoke(this, request);
        
        return tcs.Task;
    }

    public Task NotifyAsync(
        string message,
        NotificationLevel level = NotificationLevel.Info,
        CancellationToken cancellationToken = default)
    {
        NotificationSent?.Invoke(this, (message, level));
        return Task.CompletedTask;
    }

    public async Task<EscalationResult> EscalateAsync(
        EscalationRequest request,
        CancellationToken cancellationToken = default)
    {
        var tcs = new TaskCompletionSource<EscalationResult>();
        _pendingEscalations[request.Id] = tcs;

        EscalationRequested?.Invoke(this, request);

        try
        {
            return await tcs.Task;
        }
        finally
        {
            _pendingEscalations.TryRemove(request.Id, out _);
        }
    }

    /// <summary>
    /// å®ŒæˆæŒ‚èµ·çš„å‡çº§ï¼ˆç”±UI/APIè°ƒç”¨ï¼‰
    /// </summary>
    public void CompleteEscalation(EscalationResult result)
    {
        if (_pendingEscalations.TryGetValue(result.RequestId, out var tcs))
        {
            tcs.TrySetResult(result);
        }
    }
}
```

---

## ç¬¬5-7å¤©ï¼šå®¡æ‰¹å·¥ä½œæµä¸å‡çº§å¤„ç†

### 1. å‡çº§æ¨¡å‹

```csharp
namespace DawningAgents.Core.HumanLoop;

/// <summary>
/// å‡çº§åˆ°äººå·¥å¤„ç†çš„è¯·æ±‚
/// </summary>
public record EscalationRequest
{
    public string Id { get; init; } = Guid.NewGuid().ToString();
    public required string Reason { get; init; }
    public required string Description { get; init; }
    public EscalationSeverity Severity { get; init; } = EscalationSeverity.Medium;
    public string? AgentName { get; init; }
    public string? TaskId { get; init; }
    public IDictionary<string, object> Context { get; init; } = new Dictionary<string, object>();
    public IReadOnlyList<string> AttemptedSolutions { get; init; } = [];
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;
}

public enum EscalationSeverity
{
    Low,       // ä½
    Medium,    // ä¸­ç­‰
    High,      // é«˜
    Critical   // å…³é”®
}

/// <summary>
/// å‡çº§ç»“æœ
/// </summary>
public record EscalationResult
{
    public required string RequestId { get; init; }
    public EscalationAction Action { get; init; }
    public string? Resolution { get; init; }
    public string? Instructions { get; init; }
    public string? ResolvedBy { get; init; }
    public DateTime ResolvedAt { get; init; } = DateTime.UtcNow;
}

public enum EscalationAction
{
    Resolved,    // å·²è§£å†³
    Skipped,     // å·²è·³è¿‡
    Aborted,     // å·²ä¸­æ­¢
    Delegated,   // å·²å§”æ´¾
    Retried      // é‡è¯•
}
```

### 2. å®¡æ‰¹å·¥ä½œæµç®¡ç†å™¨

```csharp
namespace DawningAgents.Core.HumanLoop;

using Microsoft.Extensions.Logging;

/// <summary>
/// ç®¡ç†å®¡æ‰¹å·¥ä½œæµ
/// </summary>
public class ApprovalWorkflow
{
    private readonly IHumanInteractionHandler _handler;
    private readonly ILogger<ApprovalWorkflow> _logger;
    private readonly ApprovalConfig _config;

    public ApprovalWorkflow(
        IHumanInteractionHandler handler,
        ApprovalConfig config,
        ILogger<ApprovalWorkflow> logger)
    {
        _handler = handler;
        _config = config;
        _logger = logger;
    }

    /// <summary>
    /// æ£€æŸ¥æ“ä½œæ˜¯å¦éœ€è¦å®¡æ‰¹å¹¶è·å–å®¡æ‰¹
    /// </summary>
    public async Task<ApprovalResult> RequestApprovalAsync(
        string action,
        string description,
        IDictionary<string, object>? context = null,
        CancellationToken cancellationToken = default)
    {
        var riskLevel = AssessRiskLevel(action, context);
        
        // æ ¹æ®é£é™©çº§åˆ«æ£€æŸ¥æ˜¯å¦éœ€è¦å®¡æ‰¹
        if (!RequiresApproval(riskLevel))
        {
            _logger.LogDebug("æ“ä½œ {Action} è‡ªåŠ¨æ‰¹å‡†ï¼ˆé£é™©ï¼š{Risk}ï¼‰", action, riskLevel);
            return ApprovalResult.AutoApproved(action);
        }

        _logger.LogInformation("è¯·æ±‚å®¡æ‰¹ {Action}ï¼ˆé£é™©ï¼š{Risk}ï¼‰", action, riskLevel);

        var request = new ConfirmationRequest
        {
            Type = ConfirmationType.Binary,
            Action = action,
            Description = description,
            RiskLevel = riskLevel,
            Context = context ?? new Dictionary<string, object>(),
            Options = new[]
            {
                new ConfirmationOption { Id = "approve", Label = "æ‰¹å‡†", IsDefault = true },
                new ConfirmationOption { Id = "reject", Label = "æ‹’ç»", IsDangerous = true },
                new ConfirmationOption { Id = "modify", Label = "ä¿®æ”¹" }
            },
            Timeout = _config.ApprovalTimeout,
            DefaultOnTimeout = _config.DefaultOnTimeout
        };

        var response = await _handler.RequestConfirmationAsync(request, cancellationToken);

        return response.SelectedOption switch
        {
            "approve" => ApprovalResult.Approved(action, response.RespondedBy),
            "reject" => ApprovalResult.Rejected(action, response.Reason, response.RespondedBy),
            "modify" => ApprovalResult.Modified(action, response.ModifiedContent, response.RespondedBy),
            "timeout" => _config.DefaultOnTimeout == "approve" 
                ? ApprovalResult.AutoApproved(action) 
                : ApprovalResult.TimedOut(action),
            _ => ApprovalResult.Rejected(action, "æœªçŸ¥å“åº”")
        };
    }

    /// <summary>
    /// è¯·æ±‚å¤šäººå®¡æ‰¹
    /// </summary>
    public async Task<ApprovalResult> RequestMultiApprovalAsync(
        string action,
        string description,
        int requiredApprovals,
        IDictionary<string, object>? context = null,
        CancellationToken cancellationToken = default)
    {
        var approvals = new List<string>();
        var rejections = new List<(string Approver, string Reason)>();

        for (int i = 0; i < requiredApprovals; i++)
        {
            var result = await RequestApprovalAsync(
                $"{action}ï¼ˆå®¡æ‰¹ {i + 1}/{requiredApprovals}ï¼‰",
                description,
                context,
                cancellationToken);

            if (result.IsApproved)
            {
                approvals.Add(result.ApprovedBy ?? $"å®¡æ‰¹äºº-{i + 1}");
            }
            else
            {
                rejections.Add((result.ApprovedBy ?? $"å®¡æ‰¹äºº-{i + 1}", result.RejectionReason ?? "æœªçŸ¥"));
            }
        }

        if (approvals.Count >= requiredApprovals)
        {
            return ApprovalResult.Approved(action, string.Join(", ", approvals));
        }

        return ApprovalResult.Rejected(action, 
            $"å®¡æ‰¹æ•°é‡ä¸è¶³ï¼š{approvals.Count}/{requiredApprovals}ã€‚" +
            $"æ‹’ç»ï¼š{string.Join("ï¼›", rejections.Select(r => $"{r.Approver}ï¼š{r.Reason}"))}");
    }

    private RiskLevel AssessRiskLevel(string action, IDictionary<string, object>? context)
    {
        // æ£€æŸ¥é«˜é£é™©å…³é”®è¯
        var highRiskKeywords = new[] { "delete", "remove", "destroy", "execute", "transfer", "payment", "åˆ é™¤", "ç§»é™¤", "æ‰§è¡Œ", "è½¬è´¦", "æ”¯ä»˜" };
        var criticalKeywords = new[] { "production", "financial", "customer data", "credentials", "ç”Ÿäº§", "è´¢åŠ¡", "å®¢æˆ·æ•°æ®", "å‡­è¯" };

        var lowerAction = action.ToLower();

        if (criticalKeywords.Any(k => lowerAction.Contains(k)))
            return RiskLevel.Critical;

        if (highRiskKeywords.Any(k => lowerAction.Contains(k)))
            return RiskLevel.High;

        // æ£€æŸ¥ä¸Šä¸‹æ–‡ä¸­çš„é£é™©æŒ‡æ ‡
        if (context != null)
        {
            if (context.TryGetValue("amount", out var amount) && amount is decimal d && d > 10000)
                return RiskLevel.High;
                
            if (context.TryGetValue("environment", out var env) && env?.ToString() == "production")
                return RiskLevel.Critical;
        }

        return RiskLevel.Medium;
    }

    private bool RequiresApproval(RiskLevel level)
    {
        return level switch
        {
            RiskLevel.Low => _config.RequireApprovalForLowRisk,
            RiskLevel.Medium => _config.RequireApprovalForMediumRisk,
            RiskLevel.High => true,
            RiskLevel.Critical => true,
            _ => true
        };
    }
}

public record ApprovalConfig
{
    public bool RequireApprovalForLowRisk { get; init; } = false;
    public bool RequireApprovalForMediumRisk { get; init; } = true;
    public TimeSpan ApprovalTimeout { get; init; } = TimeSpan.FromMinutes(30);
    public string DefaultOnTimeout { get; init; } = "reject";
}

public record ApprovalResult
{
    public required string Action { get; init; }
    public bool IsApproved { get; init; }
    public bool IsAutoApproved { get; init; }
    public bool IsTimedOut { get; init; }
    public string? ApprovedBy { get; init; }
    public string? RejectionReason { get; init; }
    public string? ModifiedAction { get; init; }

    public static ApprovalResult AutoApproved(string action) => new()
    {
        Action = action,
        IsApproved = true,
        IsAutoApproved = true
    };

    public static ApprovalResult Approved(string action, string? approvedBy = null) => new()
    {
        Action = action,
        IsApproved = true,
        ApprovedBy = approvedBy
    };

    public static ApprovalResult Rejected(string action, string? reason = null, string? rejectedBy = null) => new()
    {
        Action = action,
        IsApproved = false,
        RejectionReason = reason,
        ApprovedBy = rejectedBy
    };

    public static ApprovalResult Modified(string action, string? modifiedAction, string? modifiedBy = null) => new()
    {
        Action = action,
        IsApproved = true,
        ModifiedAction = modifiedAction,
        ApprovedBy = modifiedBy
    };

    public static ApprovalResult TimedOut(string action) => new()
    {
        Action = action,
        IsApproved = false,
        IsTimedOut = true,
        RejectionReason = "å®¡æ‰¹è¯·æ±‚è¶…æ—¶"
    };
}
```

### 3. äººæœºåä½œAgent

```csharp
namespace DawningAgents.Core.HumanLoop;

using Microsoft.Extensions.Logging;

/// <summary>
/// åœ¨å†³ç­–ç‚¹å¼•å…¥äººå·¥å‚ä¸çš„Agent
/// </summary>
public class HumanInLoopAgent : IAgent
{
    private readonly IAgent _innerAgent;
    private readonly IHumanInteractionHandler _handler;
    private readonly ApprovalWorkflow _workflow;
    private readonly HumanLoopConfig _config;
    private readonly ILogger<HumanInLoopAgent> _logger;

    public string Name => $"HumanLoop({_innerAgent.Name})";

    public HumanInLoopAgent(
        IAgent innerAgent,
        IHumanInteractionHandler handler,
        HumanLoopConfig config,
        ILogger<HumanInLoopAgent> logger)
    {
        _innerAgent = innerAgent;
        _handler = handler;
        _config = config;
        _logger = logger;
        _workflow = new ApprovalWorkflow(
            handler,
            new ApprovalConfig
            {
                RequireApprovalForMediumRisk = config.RequireApprovalForMediumRisk,
                ApprovalTimeout = config.DefaultTimeout
            },
            logger);
    }

    public async Task<AgentResponse> ExecuteAsync(
        AgentContext context,
        CancellationToken cancellationToken = default)
    {
        var startTime = DateTime.UtcNow;

        try
        {
            // æ‰§è¡Œå‰ç¡®è®¤ï¼ˆå¦‚æœé…ç½®ï¼‰
            if (_config.ConfirmBeforeExecution)
            {
                var approval = await _workflow.RequestApprovalAsync(
                    "æ‰§è¡ŒAgentä»»åŠ¡",
                    $"Agent '{_innerAgent.Name}' å°†å¤„ç†ï¼š{context.Input}",
                    cancellationToken: cancellationToken);

                if (!approval.IsApproved)
                {
                    return new AgentResponse
                    {
                        Output = $"ä»»åŠ¡æœªæ‰¹å‡†ï¼š{approval.RejectionReason}",
                        IsSuccess = false,
                        Duration = DateTime.UtcNow - startTime
                    };
                }
            }

            // å¸¦å‡çº§å¤„ç†çš„æ‰§è¡Œ
            var response = await ExecuteWithEscalationAsync(context, cancellationToken);

            // è¿”å›å‰å®¡æŸ¥ï¼ˆå¦‚æœé…ç½®ï¼‰
            if (_config.ReviewBeforeReturn && response.IsSuccess)
            {
                response = await ReviewResponseAsync(response, cancellationToken);
            }

            return response;
        }
        catch (AgentEscalationException ex)
        {
            _logger.LogWarning("Agentå‡çº§ï¼š{Reason}", ex.Reason);
            
            var escalation = await _handler.EscalateAsync(new EscalationRequest
            {
                Reason = ex.Reason,
                Description = ex.Description,
                Severity = EscalationSeverity.High,
                AgentName = _innerAgent.Name,
                Context = ex.Context,
                AttemptedSolutions = ex.AttemptedSolutions
            }, cancellationToken);

            return HandleEscalationResult(escalation, startTime);
        }
    }

    private async Task<AgentResponse> ExecuteWithEscalationAsync(
        AgentContext context,
        CancellationToken cancellationToken)
    {
        var maxRetries = 3;
        Exception? lastException = null;

        for (int attempt = 0; attempt < maxRetries; attempt++)
        {
            try
            {
                return await _innerAgent.ExecuteAsync(context, cancellationToken);
            }
            catch (Exception ex) when (attempt < maxRetries - 1)
            {
                lastException = ex;
                _logger.LogWarning(ex, "ç¬¬ {Attempt} æ¬¡å°è¯•å¤±è´¥ï¼Œè¯·æ±‚æŒ‡å¯¼", attempt + 1);

                var input = await _handler.RequestInputAsync(
                    $"Agenté‡åˆ°é”™è¯¯ï¼š{ex.Message}\nè¯·æä¾›æŒ‡å¯¼æˆ–è¾“å…¥'abort'åœæ­¢ï¼š",
                    cancellationToken: cancellationToken);

                if (input.Equals("abort", StringComparison.OrdinalIgnoreCase))
                {
                    throw new OperationCanceledException("ç”¨æˆ·ä¸­æ­¢");
                }

                // å¸¦æŒ‡å¯¼é‡è¯•
                context = context with
                {
                    Input = $"{context.Input}\n\né¢å¤–æŒ‡å¯¼ï¼š{input}"
                };
            }
        }

        throw lastException ?? new Exception("æœªçŸ¥é”™è¯¯");
    }

    private async Task<AgentResponse> ReviewResponseAsync(
        AgentResponse response,
        CancellationToken cancellationToken)
    {
        var review = await _handler.RequestConfirmationAsync(new ConfirmationRequest
        {
            Type = ConfirmationType.Review,
            Action = "å®¡æŸ¥å“åº”",
            Description = $"Agentå“åº”ï¼š\n\n{response.Output}",
            RiskLevel = RiskLevel.Low,
            Options = new[]
            {
                new ConfirmationOption { Id = "approve", Label = "æ‰¹å‡†", IsDefault = true },
                new ConfirmationOption { Id = "edit", Label = "ç¼–è¾‘å“åº”" },
                new ConfirmationOption { Id = "reject", Label = "æ‹’ç»" }
            }
        }, cancellationToken);

        return review.SelectedOption switch
        {
            "approve" => response,
            "edit" => response with { Output = review.ModifiedContent ?? response.Output },
            "reject" => response with { IsSuccess = false, Output = "å“åº”è¢«å®¡æŸ¥è€…æ‹’ç»" },
            _ => response
        };
    }

    private AgentResponse HandleEscalationResult(EscalationResult result, DateTime startTime)
    {
        return result.Action switch
        {
            EscalationAction.Resolved => new AgentResponse
            {
                Output = result.Resolution ?? "å·²ç”±äººå·¥è§£å†³",
                IsSuccess = true,
                Duration = DateTime.UtcNow - startTime,
                Metadata = new Dictionary<string, object>
                {
                    ["resolved_by"] = result.ResolvedBy ?? "human",
                    ["escalation_id"] = result.RequestId
                }
            },
            EscalationAction.Skipped => new AgentResponse
            {
                Output = "æ­¥éª¤è¢«äººå·¥è·³è¿‡",
                IsSuccess = true,
                Duration = DateTime.UtcNow - startTime
            },
            _ => new AgentResponse
            {
                Output = "æ“ä½œè¢«äººå·¥ä¸­æ­¢",
                IsSuccess = false,
                Duration = DateTime.UtcNow - startTime
            }
        };
    }
}

public record HumanLoopConfig
{
    public bool ConfirmBeforeExecution { get; init; } = false;
    public bool ReviewBeforeReturn { get; init; } = false;
    public bool RequireApprovalForMediumRisk { get; init; } = true;
    public TimeSpan DefaultTimeout { get; init; } = TimeSpan.FromMinutes(30);
}

/// <summary>
/// å‡çº§åˆ°äººå·¥çš„å¼‚å¸¸
/// </summary>
public class AgentEscalationException : Exception
{
    public string Reason { get; }
    public string Description { get; }
    public IDictionary<string, object> Context { get; }
    public IReadOnlyList<string> AttemptedSolutions { get; }

    public AgentEscalationException(
        string reason,
        string description,
        IDictionary<string, object>? context = null,
        IReadOnlyList<string>? attemptedSolutions = null)
        : base(reason)
    {
        Reason = reason;
        Description = description;
        Context = context ?? new Dictionary<string, object>();
        AttemptedSolutions = attemptedSolutions ?? [];
    }
}
```

---

## å®Œæ•´ç¤ºä¾‹

```csharp
// åˆ›å»ºå¤„ç†å™¨
var handler = new ConsoleInteractionHandler(
    loggerFactory.CreateLogger<ConsoleInteractionHandler>());

// åˆ›å»ºå®¡æ‰¹å·¥ä½œæµ
var workflow = new ApprovalWorkflow(
    handler,
    new ApprovalConfig
    {
        RequireApprovalForLowRisk = false,
        RequireApprovalForMediumRisk = true,
        ApprovalTimeout = TimeSpan.FromMinutes(5)
    },
    loggerFactory.CreateLogger<ApprovalWorkflow>());

// åˆ›å»ºäººæœºåä½œAgent
var innerAgent = new ReActAgent(llm, loggerFactory.CreateLogger<ReActAgent>());
var hilAgent = new HumanInLoopAgent(
    innerAgent,
    handler,
    new HumanLoopConfig
    {
        ConfirmBeforeExecution = true,
        ReviewBeforeReturn = false,
        RequireApprovalForMediumRisk = true
    },
    loggerFactory.CreateLogger<HumanInLoopAgent>());

// å¸¦äººå·¥ç›‘ç£æ‰§è¡Œ
var response = await hilAgent.ExecuteAsync(new AgentContext
{
    Input = "ä»æ•°æ®åº“åˆ é™¤æ‰€æœ‰è¿‡æœŸçš„ç”¨æˆ·è´¦æˆ·"
});

Console.WriteLine(response.Output);

// ç›´æ¥ä½¿ç”¨å®¡æ‰¹å·¥ä½œæµ
var approval = await workflow.RequestApprovalAsync(
    "è½¬è´¦",
    "å‘è´¦æˆ· XYZ-123 è½¬è´¦ 50,000 å…ƒ",
    new Dictionary<string, object>
    {
        ["amount"] = 50000m,
        ["destination"] = "XYZ-123"
    });

if (approval.IsApproved)
{
    Console.WriteLine($"è½¬è´¦å·²ç”± {approval.ApprovedBy} æ‰¹å‡†");
}
else
{
    Console.WriteLine($"è½¬è´¦è¢«æ‹’ç»ï¼š{approval.RejectionReason}");
}
```

---

## æ€»ç»“

### ç¬¬10å‘¨äº¤ä»˜ç‰©

```
src/DawningAgents.Core/
â””â”€â”€ HumanLoop/
    â”œâ”€â”€ ConfirmationRequest.cs      # è¯·æ±‚æ¨¡å‹
    â”œâ”€â”€ ConfirmationResponse.cs     # å“åº”æ¨¡å‹
    â”œâ”€â”€ EscalationRequest.cs        # å‡çº§æ¨¡å‹
    â”œâ”€â”€ EscalationResult.cs         # å‡çº§ç»“æœ
    â”œâ”€â”€ IHumanInteractionHandler.cs # å¤„ç†å™¨æ¥å£
    â”œâ”€â”€ ApprovalWorkflow.cs         # å®¡æ‰¹é€»è¾‘
    â”œâ”€â”€ HumanInLoopAgent.cs         # AgentåŒ…è£…å™¨
    â””â”€â”€ Handlers/
        â”œâ”€â”€ ConsoleInteractionHandler.cs  # æ§åˆ¶å°UI
        â””â”€â”€ AsyncCallbackHandler.cs       # å¼‚æ­¥/API
```

### äººæœºåä½œæ¨¡å¼

| æ¨¡å¼ | ç”¨ä¾‹ |
|------|------|
| **ç¡®è®¤** | äºŒå…ƒæ˜¯/å¦å†³ç­– |
| **å¤šé€‰** | ä»é€‰é¡¹ä¸­é€‰æ‹© |
| **å®¡æŸ¥** | å®¡æŸ¥å’Œä¿®æ”¹è¾“å‡º |
| **å®¡æ‰¹å·¥ä½œæµ** | åŸºäºé£é™©çš„å®¡æ‰¹ |
| **å‡çº§** | å¤„ç†é”™è¯¯/è¾¹ç¼˜æƒ…å†µ |
| **å¤šäººå®¡æ‰¹** | å…³é”®æ“ä½œ |

### ç¬¬äº”é˜¶æ®µå®Œæˆï¼

å®Œæˆç¬¬9-10å‘¨åï¼Œæ‚¨å·²å­¦ä¹ ï¼š
- å®‰å…¨ä¸æŠ¤æ ï¼ˆè¾“å…¥éªŒè¯ã€å†…å®¹å®¡æ ¸ã€é€Ÿç‡é™åˆ¶ï¼‰
- äººæœºåä½œæ¨¡å¼ï¼ˆç¡®è®¤ã€å®¡æ‰¹ã€å‡çº§ï¼‰

ä¸‹ä¸€æ­¥ï¼šç¬¬å…­é˜¶æ®µ - ç”Ÿäº§å°±ç»ªï¼ˆç¬¬11-12å‘¨ï¼‰
