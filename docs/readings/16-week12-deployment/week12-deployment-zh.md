# ç¬¬12å‘¨ï¼šéƒ¨ç½²ä¸æ‰©å±•

> ç¬¬å…­é˜¶æ®µï¼šç”Ÿäº§å°±ç»ª
> ç¬¬12å‘¨å­¦ä¹ ææ–™ï¼šå®¹å™¨åŒ–ã€é…ç½®ç®¡ç†ã€æ‰©å±•ä¸ç”Ÿäº§éƒ¨ç½²

---

## ç¬¬1-2å¤©ï¼šå®¹å™¨åŒ–

### 1. Agent Dockeræ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Agentéƒ¨ç½²æ¶æ„                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                      è´Ÿè½½å‡è¡¡å™¨                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                            â”‚                                     â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚         â–¼                  â–¼                  â–¼                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚   Agent    â”‚    â”‚   Agent    â”‚    â”‚   Agent    â”‚            â”‚
â”‚  â”‚   å®ä¾‹     â”‚    â”‚   å®ä¾‹     â”‚    â”‚   å®ä¾‹     â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚         â”‚                  â”‚                  â”‚                 â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                            â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              å…±äº«æœåŠ¡ (Redis, æ•°æ®åº“)                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Dockerfile

```dockerfile
# DawningAgentsçš„Dockerfile

# æ„å»ºé˜¶æ®µ
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

# å¤åˆ¶é¡¹ç›®æ–‡ä»¶
COPY ["src/DawningAgents.Core/DawningAgents.Core.csproj", "DawningAgents.Core/"]
COPY ["src/DawningAgents.Api/DawningAgents.Api.csproj", "DawningAgents.Api/"]

# è¿˜åŸä¾èµ–
RUN dotnet restore "DawningAgents.Api/DawningAgents.Api.csproj"

# å¤åˆ¶æºä»£ç 
COPY src/ .

# æ„å»º
RUN dotnet build "DawningAgents.Api/DawningAgents.Api.csproj" -c Release -o /app/build

# å‘å¸ƒé˜¶æ®µ
FROM build AS publish
RUN dotnet publish "DawningAgents.Api/DawningAgents.Api.csproj" -c Release -o /app/publish /p:UseAppHost=false

# è¿è¡Œæ—¶é˜¶æ®µ
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS final
WORKDIR /app

# ä¸ºå®‰å…¨åˆ›å»ºérootç”¨æˆ·
RUN adduser --disabled-password --gecos '' appuser && chown -R appuser /app
USER appuser

# å¤åˆ¶å‘å¸ƒçš„åº”ç”¨
COPY --from=publish /app/publish .

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# æš´éœ²ç«¯å£
EXPOSE 8080

# è®¾ç½®ç¯å¢ƒå˜é‡
ENV ASPNETCORE_URLS=http://+:8080
ENV ASPNETCORE_ENVIRONMENT=Production

ENTRYPOINT ["dotnet", "DawningAgents.Api.dll"]
```

### 3. Docker Compose

```yaml
# docker-compose.yml

version: '3.8'

services:
  agent-api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ConnectionStrings__Redis=redis:6379
      - LLM__Provider=OpenAI
      - LLM__ApiKey=${OPENAI_API_KEY}
      - Telemetry__OtlpEndpoint=http://otel-collector:4317
    depends_on:
      - redis
      - otel-collector
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '2'
          memory: 4G
        reservations:
          cpus: '0.5'
          memory: 512M
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes

  otel-collector:
    image: otel/opentelemetry-collector-contrib:latest
    ports:
      - "4317:4317"   # OTLP gRPC
      - "4318:4318"   # OTLP HTTP
      - "8888:8888"   # PrometheusæŒ‡æ ‡
    volumes:
      - ./config/otel-collector.yaml:/etc/otelcol-contrib/config.yaml
    command: ["--config=/etc/otelcol-contrib/config.yaml"]

volumes:
  redis-data:
```

---

## ç¬¬3-4å¤©ï¼šé…ç½®ç®¡ç†

### 1. é…ç½®æä¾›è€…

```csharp
namespace DawningAgents.Core.Configuration;

using Microsoft.Extensions.Configuration;

/// <summary>
/// å¸¦ç¯å¢ƒç‰¹å®šè®¾ç½®çš„Agenté…ç½®
/// </summary>
public class AgentConfiguration
{
    /// <summary>
    /// ä»å„ç§æ¥æºåŠ è½½é…ç½®
    /// </summary>
    public static IConfiguration Build(string[] args)
    {
        var environment = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "Development";
        
        return new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
            .AddJsonFile($"appsettings.{environment}.json", optional: true, reloadOnChange: true)
            .AddEnvironmentVariables()
            .AddCommandLine(args)
            .Build();
    }
}

/// <summary>
/// å¼ºç±»å‹é…ç½®é€‰é¡¹
/// </summary>
public record AgentOptions
{
    public const string SectionName = "Agent";
    
    public string Name { get; init; } = "DefaultAgent";
    public int MaxIterations { get; init; } = 10;
    public int MaxTokensPerRequest { get; init; } = 4000;
    public TimeSpan RequestTimeout { get; init; } = TimeSpan.FromMinutes(5);
    public bool EnableSafetyGuardrails { get; init; } = true;
}

public record LLMOptions
{
    public const string SectionName = "LLM";
    
    public string Provider { get; init; } = "OpenAI";
    public string? ApiKey { get; init; }
    public string? Endpoint { get; init; }
    public string Model { get; init; } = "gpt-4";
    public double Temperature { get; init; } = 0.7;
    public int MaxRetries { get; init; } = 3;
    public TimeSpan RetryDelay { get; init; } = TimeSpan.FromSeconds(1);
}

public record ScalingOptions
{
    public const string SectionName = "Scaling";
    
    public int MinInstances { get; init; } = 1;
    public int MaxInstances { get; init; } = 10;
    public int TargetCpuPercent { get; init; } = 70;
    public int TargetMemoryPercent { get; init; } = 80;
    public int ScaleUpCooldownSeconds { get; init; } = 60;
    public int ScaleDownCooldownSeconds { get; init; } = 300;
}

public record CacheOptions
{
    public const string SectionName = "Cache";
    
    public bool Enabled { get; init; } = true;
    public string Provider { get; init; } = "Redis";
    public string? ConnectionString { get; init; }
    public TimeSpan DefaultExpiration { get; init; } = TimeSpan.FromHours(1);
    public int MaxCacheSize { get; init; } = 10000;
}
```

### 2. é…ç½®æ–‡ä»¶

```json
// appsettings.json
{
  "Agent": {
    "Name": "DawningAgent",
    "MaxIterations": 10,
    "MaxTokensPerRequest": 4000,
    "RequestTimeout": "00:05:00",
    "EnableSafetyGuardrails": true
  },
  "LLM": {
    "Provider": "OpenAI",
    "Model": "gpt-4",
    "Temperature": 0.7,
    "MaxRetries": 3,
    "RetryDelay": "00:00:01"
  },
  "Scaling": {
    "MinInstances": 1,
    "MaxInstances": 10,
    "TargetCpuPercent": 70,
    "TargetMemoryPercent": 80
  },
  "Cache": {
    "Enabled": true,
    "Provider": "Redis",
    "DefaultExpiration": "01:00:00"
  },
  "Telemetry": {
    "ServiceName": "DawningAgents",
    "EnableLogging": true,
    "EnableMetrics": true,
    "EnableTracing": true,
    "TraceSampleRate": 0.1
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
```

```json
// appsettings.Production.json
{
  "Agent": {
    "MaxIterations": 15,
    "RequestTimeout": "00:10:00"
  },
  "LLM": {
    "MaxRetries": 5
  },
  "Scaling": {
    "MinInstances": 3,
    "MaxInstances": 50
  },
  "Telemetry": {
    "TraceSampleRate": 0.01,
    "OtlpEndpoint": "http://otel-collector:4317"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Warning",
      "DawningAgents": "Information"
    }
  }
}
```

### 3. å¯†é’¥ç®¡ç†

```csharp
namespace DawningAgents.Core.Configuration;

using Azure.Identity;
using Azure.Security.KeyVault.Secrets;

/// <summary>
/// å®‰å…¨å¯†é’¥ç®¡ç†
/// </summary>
public interface ISecretsManager
{
    Task<string?> GetSecretAsync(string name, CancellationToken cancellationToken = default);
    Task SetSecretAsync(string name, string value, CancellationToken cancellationToken = default);
}

/// <summary>
/// Azure Key Vaultå®ç°
/// </summary>
public class AzureKeyVaultSecretsManager : ISecretsManager
{
    private readonly SecretClient _client;
    private readonly IMemoryCache _cache;
    private readonly TimeSpan _cacheExpiration = TimeSpan.FromMinutes(5);

    public AzureKeyVaultSecretsManager(string vaultUri, IMemoryCache cache)
    {
        _client = new SecretClient(new Uri(vaultUri), new DefaultAzureCredential());
        _cache = cache;
    }

    public async Task<string?> GetSecretAsync(string name, CancellationToken cancellationToken = default)
    {
        var cacheKey = $"secret:{name}";
        
        if (_cache.TryGetValue(cacheKey, out string? cachedValue))
        {
            return cachedValue;
        }

        try
        {
            var secret = await _client.GetSecretAsync(name, cancellationToken: cancellationToken);
            var value = secret.Value.Value;
            
            _cache.Set(cacheKey, value, _cacheExpiration);
            return value;
        }
        catch (Azure.RequestFailedException ex) when (ex.Status == 404)
        {
            return null;
        }
    }

    public async Task SetSecretAsync(string name, string value, CancellationToken cancellationToken = default)
    {
        await _client.SetSecretAsync(name, value, cancellationToken);
        _cache.Remove($"secret:{name}");
    }
}

/// <summary>
/// ç”¨äºå¼€å‘çš„ç¯å¢ƒå˜é‡å¯†é’¥
/// </summary>
public class EnvironmentSecretsManager : ISecretsManager
{
    public Task<string?> GetSecretAsync(string name, CancellationToken cancellationToken = default)
    {
        var envName = name.Replace("-", "_").Replace(":", "__").ToUpperInvariant();
        return Task.FromResult(Environment.GetEnvironmentVariable(envName));
    }

    public Task SetSecretAsync(string name, string value, CancellationToken cancellationToken = default)
    {
        var envName = name.Replace("-", "_").Replace(":", "__").ToUpperInvariant();
        Environment.SetEnvironmentVariable(envName, value);
        return Task.CompletedTask;
    }
}
```

---

## ç¬¬5-7å¤©ï¼šæ‰©å±•ä¸ç”Ÿäº§éƒ¨ç½²

### 1. è¯·æ±‚é˜Ÿåˆ—ä¸å·¥ä½œæ± 

```csharp
namespace DawningAgents.Core.Scaling;

using System.Threading.Channels;
using Microsoft.Extensions.Logging;

/// <summary>
/// Agentå¤„ç†çš„è¯·æ±‚é˜Ÿåˆ—
/// </summary>
public class AgentRequestQueue
{
    private readonly Channel<AgentWorkItem> _channel;
    private readonly ILogger<AgentRequestQueue> _logger;

    public AgentRequestQueue(int capacity, ILogger<AgentRequestQueue> logger)
    {
        _channel = Channel.CreateBounded<AgentWorkItem>(new BoundedChannelOptions(capacity)
        {
            FullMode = BoundedChannelFullMode.Wait,
            SingleReader = false,
            SingleWriter = false
        });
        _logger = logger;
    }

    /// <summary>
    /// å…¥é˜Ÿå·¥ä½œé¡¹
    /// </summary>
    public async ValueTask EnqueueAsync(AgentWorkItem item, CancellationToken cancellationToken = default)
    {
        await _channel.Writer.WriteAsync(item, cancellationToken);
        _logger.LogDebug("å·¥ä½œé¡¹ {WorkItemId} å·²å…¥é˜Ÿ", item.Id);
    }

    /// <summary>
    /// å°è¯•å‡ºé˜Ÿå·¥ä½œé¡¹
    /// </summary>
    public async ValueTask<AgentWorkItem?> DequeueAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            return await _channel.Reader.ReadAsync(cancellationToken);
        }
        catch (OperationCanceledException)
        {
            return null;
        }
    }

    /// <summary>
    /// è·å–å½“å‰é˜Ÿåˆ—é•¿åº¦
    /// </summary>
    public int Count => _channel.Reader.Count;

    /// <summary>
    /// æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦å¯ä»¥æ¥å—æ›´å¤šé¡¹
    /// </summary>
    public bool CanWrite => _channel.Writer.TryComplete() == false;
}

public record AgentWorkItem
{
    public string Id { get; init; } = Guid.NewGuid().ToString();
    public required AgentContext Context { get; init; }
    public required TaskCompletionSource<AgentResponse> CompletionSource { get; init; }
    public DateTime EnqueuedAt { get; init; } = DateTime.UtcNow;
    public string? Priority { get; init; }
    public CancellationToken CancellationToken { get; init; }
}

/// <summary>
/// å¤„ç†Agentè¯·æ±‚çš„å·¥ä½œæ± 
/// </summary>
public class AgentWorkerPool : IDisposable
{
    private readonly IAgent _agent;
    private readonly AgentRequestQueue _queue;
    private readonly ILogger<AgentWorkerPool> _logger;
    private readonly List<Task> _workers = [];
    private readonly CancellationTokenSource _cts = new();
    private readonly int _workerCount;

    public AgentWorkerPool(
        IAgent agent,
        AgentRequestQueue queue,
        int workerCount,
        ILogger<AgentWorkerPool> logger)
    {
        _agent = agent;
        _queue = queue;
        _workerCount = workerCount;
        _logger = logger;
    }

    /// <summary>
    /// å¯åŠ¨å·¥ä½œæ± 
    /// </summary>
    public void Start()
    {
        for (int i = 0; i < _workerCount; i++)
        {
            var workerId = i;
            _workers.Add(Task.Run(() => WorkerLoopAsync(workerId, _cts.Token)));
        }
        
        _logger.LogInformation("å·²å¯åŠ¨ {WorkerCount} ä¸ªAgentå·¥ä½œçº¿ç¨‹", _workerCount);
    }

    private async Task WorkerLoopAsync(int workerId, CancellationToken cancellationToken)
    {
        _logger.LogDebug("å·¥ä½œçº¿ç¨‹ {WorkerId} å·²å¯åŠ¨", workerId);

        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                var item = await _queue.DequeueAsync(cancellationToken);
                if (item == null) continue;

                using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
                    cancellationToken, item.CancellationToken);

                try
                {
                    var response = await _agent.ExecuteAsync(item.Context, linkedCts.Token);
                    item.CompletionSource.TrySetResult(response);
                }
                catch (OperationCanceledException)
                {
                    item.CompletionSource.TrySetCanceled();
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "å·¥ä½œçº¿ç¨‹ {WorkerId} å¤„ç†é¡¹ {ItemId} å¤±è´¥", workerId, item.Id);
                    item.CompletionSource.TrySetException(ex);
                }
            }
            catch (OperationCanceledException)
            {
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "å·¥ä½œçº¿ç¨‹ {WorkerId} é‡åˆ°æ„å¤–é”™è¯¯", workerId);
                await Task.Delay(1000, cancellationToken);
            }
        }

        _logger.LogDebug("å·¥ä½œçº¿ç¨‹ {WorkerId} å·²åœæ­¢", workerId);
    }

    public void Dispose()
    {
        _cts.Cancel();
        Task.WhenAll(_workers).Wait(TimeSpan.FromSeconds(30));
        _cts.Dispose();
    }
}
```

### 2. è´Ÿè½½å‡è¡¡å™¨ä¸ç†”æ–­å™¨

```csharp
namespace DawningAgents.Core.Scaling;

using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;

/// <summary>
/// å¤šAgentå®ä¾‹çš„è´Ÿè½½å‡è¡¡å™¨
/// </summary>
public class AgentLoadBalancer
{
    private readonly List<AgentInstance> _instances = [];
    private readonly ILogger<AgentLoadBalancer> _logger;
    private int _roundRobinIndex = 0;

    public AgentLoadBalancer(ILogger<AgentLoadBalancer> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// æ³¨å†ŒAgentå®ä¾‹
    /// </summary>
    public void RegisterInstance(AgentInstance instance)
    {
        _instances.Add(instance);
        _logger.LogInformation("å·²æ³¨å†ŒAgentå®ä¾‹ {InstanceId}", instance.Id);
    }

    /// <summary>
    /// è·å–ä¸‹ä¸€ä¸ªå¯ç”¨å®ä¾‹ï¼ˆè½®è¯¢ï¼‰
    /// </summary>
    public AgentInstance? GetNextInstance()
    {
        var healthyInstances = _instances.Where(i => i.IsHealthy).ToList();
        if (healthyInstances.Count == 0)
            return null;

        var index = Interlocked.Increment(ref _roundRobinIndex) % healthyInstances.Count;
        return healthyInstances[index];
    }

    /// <summary>
    /// è·å–è´Ÿè½½æœ€å°çš„å®ä¾‹
    /// </summary>
    public AgentInstance? GetLeastLoadedInstance()
    {
        return _instances
            .Where(i => i.IsHealthy)
            .OrderBy(i => i.ActiveRequests)
            .FirstOrDefault();
    }
}

public class AgentInstance
{
    public string Id { get; init; } = Guid.NewGuid().ToString();
    public required IAgent Agent { get; init; }
    public string Endpoint { get; init; } = "";
    public bool IsHealthy { get; set; } = true;
    public int ActiveRequests { get; set; }
    public DateTime LastHealthCheck { get; set; } = DateTime.UtcNow;
}

/// <summary>
/// å®¹é”™ç†”æ–­å™¨
/// </summary>
public class CircuitBreaker
{
    private readonly int _failureThreshold;
    private readonly TimeSpan _resetTimeout;
    private readonly ILogger<CircuitBreaker> _logger;
    
    private int _failureCount;
    private DateTime _lastFailureTime;
    private CircuitState _state = CircuitState.Closed;
    private readonly object _lock = new();

    public CircuitBreaker(
        int failureThreshold,
        TimeSpan resetTimeout,
        ILogger<CircuitBreaker> logger)
    {
        _failureThreshold = failureThreshold;
        _resetTimeout = resetTimeout;
        _logger = logger;
    }

    public CircuitState State
    {
        get
        {
            lock (_lock)
            {
                if (_state == CircuitState.Open && 
                    DateTime.UtcNow - _lastFailureTime > _resetTimeout)
                {
                    _state = CircuitState.HalfOpen;
                    _logger.LogInformation("ç†”æ–­å™¨è½¬æ¢ä¸ºåŠå¼€çŠ¶æ€");
                }
                return _state;
            }
        }
    }

    /// <summary>
    /// å¸¦ç†”æ–­å™¨ä¿æŠ¤æ‰§è¡Œ
    /// </summary>
    public async Task<T> ExecuteAsync<T>(Func<Task<T>> action)
    {
        if (State == CircuitState.Open)
        {
            throw new CircuitBreakerOpenException("ç†”æ–­å™¨å¤„äºæ‰“å¼€çŠ¶æ€");
        }

        try
        {
            var result = await action();
            OnSuccess();
            return result;
        }
        catch (Exception ex)
        {
            OnFailure();
            throw;
        }
    }

    private void OnSuccess()
    {
        lock (_lock)
        {
            _failureCount = 0;
            if (_state == CircuitState.HalfOpen)
            {
                _state = CircuitState.Closed;
                _logger.LogInformation("ç†”æ–­å™¨åœ¨æˆåŠŸè¯·æ±‚åå…³é—­");
            }
        }
    }

    private void OnFailure()
    {
        lock (_lock)
        {
            _failureCount++;
            _lastFailureTime = DateTime.UtcNow;

            if (_failureCount >= _failureThreshold)
            {
                _state = CircuitState.Open;
                _logger.LogWarning("ç†”æ–­å™¨åœ¨ {FailureCount} æ¬¡å¤±è´¥åæ‰“å¼€", _failureCount);
            }
        }
    }
}

public enum CircuitState
{
    Closed,    // æ­£å¸¸è¿è¡Œ
    Open,      // é˜»æ­¢è¯·æ±‚
    HalfOpen   // æµ‹è¯•æ¢å¤
}

public class CircuitBreakerOpenException : Exception
{
    public CircuitBreakerOpenException(string message) : base(message) { }
}
```

### 3. è‡ªåŠ¨æ‰©å±•å™¨

```csharp
namespace DawningAgents.Core.Scaling;

using Microsoft.Extensions.Logging;

/// <summary>
/// åŸºäºæŒ‡æ ‡çš„è‡ªåŠ¨æ‰©å±•å™¨
/// </summary>
public class AgentAutoScaler
{
    private readonly ScalingOptions _options;
    private readonly ILogger<AgentAutoScaler> _logger;
    private readonly Func<Task<ScalingMetrics>> _metricsProvider;
    private readonly Func<int, Task> _scaleAction;
    
    private int _currentInstances;
    private DateTime _lastScaleUp = DateTime.MinValue;
    private DateTime _lastScaleDown = DateTime.MinValue;

    public AgentAutoScaler(
        ScalingOptions options,
        Func<Task<ScalingMetrics>> metricsProvider,
        Func<int, Task> scaleAction,
        ILogger<AgentAutoScaler> logger)
    {
        _options = options;
        _metricsProvider = metricsProvider;
        _scaleAction = scaleAction;
        _logger = logger;
        _currentInstances = options.MinInstances;
    }

    /// <summary>
    /// è¯„ä¼°å¹¶åº”ç”¨æ‰©å±•å†³ç­–
    /// </summary>
    public async Task EvaluateAsync()
    {
        var metrics = await _metricsProvider();
        var decision = MakeScalingDecision(metrics);

        if (decision.Action == ScalingAction.None)
            return;

        var newCount = decision.Action == ScalingAction.ScaleUp
            ? Math.Min(_currentInstances + decision.Delta, _options.MaxInstances)
            : Math.Max(_currentInstances - decision.Delta, _options.MinInstances);

        if (newCount != _currentInstances)
        {
            await ApplyScalingAsync(newCount, decision);
        }
    }

    private ScalingDecision MakeScalingDecision(ScalingMetrics metrics)
    {
        var now = DateTime.UtcNow;

        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
        if (metrics.CpuPercent > _options.TargetCpuPercent ||
            metrics.MemoryPercent > _options.TargetMemoryPercent ||
            metrics.QueueLength > _currentInstances * 10)
        {
            if (now - _lastScaleUp > TimeSpan.FromSeconds(_options.ScaleUpCooldownSeconds))
            {
                var delta = CalculateScaleUpDelta(metrics);
                return new ScalingDecision
                {
                    Action = ScalingAction.ScaleUp,
                    Delta = delta,
                    Reason = $"CPU: {metrics.CpuPercent}%, å†…å­˜: {metrics.MemoryPercent}%, é˜Ÿåˆ—: {metrics.QueueLength}"
                };
            }
        }

        // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç¼©å®¹
        if (metrics.CpuPercent < _options.TargetCpuPercent * 0.5 &&
            metrics.MemoryPercent < _options.TargetMemoryPercent * 0.5 &&
            metrics.QueueLength < _currentInstances * 2)
        {
            if (now - _lastScaleDown > TimeSpan.FromSeconds(_options.ScaleDownCooldownSeconds))
            {
                return new ScalingDecision
                {
                    Action = ScalingAction.ScaleDown,
                    Delta = 1,
                    Reason = $"ä½åˆ©ç”¨ç‡ - CPU: {metrics.CpuPercent}%, å†…å­˜: {metrics.MemoryPercent}%"
                };
            }
        }

        return new ScalingDecision { Action = ScalingAction.None };
    }

    private int CalculateScaleUpDelta(ScalingMetrics metrics)
    {
        // è®¡ç®—éœ€è¦å¤šå°‘å®ä¾‹
        var cpuRatio = metrics.CpuPercent / _options.TargetCpuPercent;
        var memoryRatio = metrics.MemoryPercent / _options.TargetMemoryPercent;
        var targetRatio = Math.Max(cpuRatio, memoryRatio);
        
        var targetInstances = (int)Math.Ceiling(_currentInstances * targetRatio);
        return Math.Max(1, targetInstances - _currentInstances);
    }

    private async Task ApplyScalingAsync(int newCount, ScalingDecision decision)
    {
        _logger.LogInformation(
            "ä» {Current} æ‰©å±•åˆ° {New} ä¸ªå®ä¾‹ã€‚åŸå› ï¼š{Reason}",
            _currentInstances, newCount, decision.Reason);

        try
        {
            await _scaleAction(newCount);
            
            if (decision.Action == ScalingAction.ScaleUp)
                _lastScaleUp = DateTime.UtcNow;
            else
                _lastScaleDown = DateTime.UtcNow;

            _currentInstances = newCount;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "æ‰©å±•åˆ° {NewCount} ä¸ªå®ä¾‹å¤±è´¥", newCount);
        }
    }
}

public record ScalingMetrics
{
    public double CpuPercent { get; init; }
    public double MemoryPercent { get; init; }
    public int QueueLength { get; init; }
    public int ActiveRequests { get; init; }
    public double AvgLatencyMs { get; init; }
}

public record ScalingDecision
{
    public ScalingAction Action { get; init; }
    public int Delta { get; init; }
    public string? Reason { get; init; }
}

public enum ScalingAction
{
    None,      // æ— æ“ä½œ
    ScaleUp,   // æ‰©å®¹
    ScaleDown  // ç¼©å®¹
}
```

### 4. APIå¯åŠ¨é…ç½®

```csharp
namespace DawningAgents.Api;

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using DawningAgents.Core.Configuration;
using DawningAgents.Core.Observability;
using DawningAgents.Core.Scaling;
using DawningAgents.Core.Safety;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);

        // åŠ è½½é…ç½®
        var config = AgentConfiguration.Build(args);
        builder.Configuration.AddConfiguration(config);

        // é…ç½®é€‰é¡¹
        builder.Services.Configure<AgentOptions>(config.GetSection(AgentOptions.SectionName));
        builder.Services.Configure<LLMOptions>(config.GetSection(LLMOptions.SectionName));
        builder.Services.Configure<ScalingOptions>(config.GetSection(ScalingOptions.SectionName));
        builder.Services.Configure<TelemetryConfig>(config.GetSection("Telemetry"));

        // æ³¨å†ŒæœåŠ¡
        ConfigureServices(builder.Services, config);

        var app = builder.Build();

        // é…ç½®ä¸­é—´ä»¶
        ConfigureMiddleware(app);

        app.Run();
    }

    private static void ConfigureServices(IServiceCollection services, IConfiguration config)
    {
        // é¥æµ‹
        var telemetryConfig = config.GetSection("Telemetry").Get<TelemetryConfig>() ?? new TelemetryConfig();
        services.AddSingleton(telemetryConfig);
        services.AddSingleton<AgentTelemetry>();

        // LLMæä¾›è€…
        var llmOptions = config.GetSection(LLMOptions.SectionName).Get<LLMOptions>() ?? new LLMOptions();
        services.AddSingleton<ILLMProvider>(sp =>
        {
            return llmOptions.Provider switch
            {
                "OpenAI" => new OpenAIProvider(llmOptions),
                "Azure" => new AzureOpenAIProvider(llmOptions),
                _ => throw new InvalidOperationException($"æœªçŸ¥çš„LLMæä¾›è€…ï¼š{llmOptions.Provider}")
            };
        });

        // Agent
        services.AddSingleton<IAgent>(sp =>
        {
            var llm = sp.GetRequiredService<ILLMProvider>();
            var logger = sp.GetRequiredService<ILoggerFactory>();
            var telemetry = sp.GetRequiredService<AgentTelemetry>();
            var safetyConfig = new SafetyConfig();

            // æ„å»ºAgentæµæ°´çº¿
            var innerAgent = new ReActAgent(llm, logger.CreateLogger<ReActAgent>());
            
            // åŒ…è£…å®‰å…¨æ€§
            var guardrailPipeline = new GuardrailPipeline(logger.CreateLogger<GuardrailPipeline>())
                .Add(new InputValidator(safetyConfig, logger.CreateLogger<InputValidator>()))
                .Add(new SensitiveDataFilter(safetyConfig, logger.CreateLogger<SensitiveDataFilter>()));
            
            var safeAgent = new SafeAgent(
                innerAgent, guardrailPipeline, safetyConfig, logger.CreateLogger<SafeAgent>());
            
            // åŒ…è£…å¯è§‚æµ‹æ€§
            return new ObservableAgent(safeAgent, telemetry, logger.CreateLogger<ObservableAgent>(), telemetryConfig);
        });

        // è¯·æ±‚é˜Ÿåˆ—å’Œå·¥ä½œæ± 
        services.AddSingleton<AgentRequestQueue>(sp =>
            new AgentRequestQueue(1000, sp.GetRequiredService<ILogger<AgentRequestQueue>>()));
        
        services.AddSingleton<AgentWorkerPool>(sp =>
        {
            var agent = sp.GetRequiredService<IAgent>();
            var queue = sp.GetRequiredService<AgentRequestQueue>();
            var workerCount = Environment.ProcessorCount * 2;
            return new AgentWorkerPool(agent, queue, workerCount, sp.GetRequiredService<ILogger<AgentWorkerPool>>());
        });

        // å¥åº·æ£€æŸ¥
        services.AddHealthChecks()
            .AddCheck<AgentHealthCheck>("agent")
            .AddCheck<LLMHealthCheck>("llm");

        // APIæ§åˆ¶å™¨
        services.AddControllers();
        services.AddEndpointsApiExplorer();
        services.AddSwaggerGen();
    }

    private static void ConfigureMiddleware(WebApplication app)
    {
        // å¯åŠ¨å·¥ä½œæ± 
        var workerPool = app.Services.GetRequiredService<AgentWorkerPool>();
        workerPool.Start();

        // å¼€å‘ç¯å¢ƒSwagger
        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }

        // å¥åº·æ£€æŸ¥ç«¯ç‚¹
        app.MapHealthChecks("/health");

        // APIç«¯ç‚¹
        app.MapControllers();

        // æŒ‡æ ‡ç«¯ç‚¹
        app.MapGet("/metrics", (AgentTelemetry telemetry) =>
        {
            // è¿”å›Prometheusæ ¼å¼çš„æŒ‡æ ‡
            return Results.Ok();
        });
    }
}
```

---

## Kuberneteséƒ¨ç½²

```yaml
# kubernetes/deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: dawning-agents
  labels:
    app: dawning-agents
spec:
  replicas: 3
  selector:
    matchLabels:
      app: dawning-agents
  template:
    metadata:
      labels:
        app: dawning-agents
    spec:
      containers:
      - name: agent
        image: dawning-agents:latest
        ports:
        - containerPort: 8080
        env:
        - name: ASPNETCORE_ENVIRONMENT
          value: "Production"
        - name: LLM__ApiKey
          valueFrom:
            secretKeyRef:
              name: llm-secrets
              key: api-key
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "4Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: dawning-agents
spec:
  selector:
    app: dawning-agents
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: dawning-agents-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: dawning-agents
  minReplicas: 3
  maxReplicas: 50
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

---

## æ€»ç»“

### ç¬¬12å‘¨äº¤ä»˜ç‰©

```
src/DawningAgents.Core/
â”œâ”€â”€ Configuration/
â”‚   â”œâ”€â”€ AgentConfiguration.cs      # é…ç½®åŠ è½½
â”‚   â”œâ”€â”€ AgentOptions.cs            # ç±»å‹åŒ–é€‰é¡¹
â”‚   â””â”€â”€ SecretsManager.cs          # å¯†é’¥ç®¡ç†
â””â”€â”€ Scaling/
    â”œâ”€â”€ AgentRequestQueue.cs       # è¯·æ±‚é˜Ÿåˆ—
    â”œâ”€â”€ AgentWorkerPool.cs         # å·¥ä½œæ± 
    â”œâ”€â”€ AgentLoadBalancer.cs       # è´Ÿè½½å‡è¡¡
    â”œâ”€â”€ CircuitBreaker.cs          # å®¹é”™
    â””â”€â”€ AgentAutoScaler.cs         # è‡ªåŠ¨æ‰©å±•

docker/
â”œâ”€â”€ Dockerfile                     # å®¹å™¨é•œåƒ
â””â”€â”€ docker-compose.yml             # æœ¬åœ°éƒ¨ç½²

kubernetes/
â”œâ”€â”€ deployment.yaml                # K8séƒ¨ç½²
â”œâ”€â”€ service.yaml                   # K8sæœåŠ¡
â””â”€â”€ hpa.yaml                       # æ°´å¹³Podè‡ªåŠ¨æ‰©å±•
```

### ç”Ÿäº§æ£€æŸ¥æ¸…å•

| ç±»åˆ« | é¡¹ç›® |
|------|------|
| **å®‰å…¨æ€§** | âœ… érootå®¹å™¨ï¼Œâœ… å¯†é’¥ç®¡ç†ï¼Œâœ… è¾“å…¥éªŒè¯ |
| **å¯è§‚æµ‹æ€§** | âœ… ç»“æ„åŒ–æ—¥å¿—ï¼Œâœ… æŒ‡æ ‡ï¼Œâœ… åˆ†å¸ƒå¼è¿½è¸ª |
| **å¯é æ€§** | âœ… å¥åº·æ£€æŸ¥ï¼Œâœ… ç†”æ–­å™¨ï¼Œâœ… ä¼˜é›…å…³é—­ |
| **å¯æ‰©å±•æ€§** | âœ… æ°´å¹³æ‰©å±•ï¼Œâœ… è‡ªåŠ¨æ‰©å±•ï¼Œâœ… è´Ÿè½½å‡è¡¡ |
| **é…ç½®** | âœ… ç¯å¢ƒç‰¹å®šï¼Œâœ… çƒ­é‡è½½ï¼Œâœ… éªŒè¯ |

### ğŸ‰ æ­å–œï¼

æ‚¨å·²å®Œæˆ12å‘¨çš„Dawning Agentså­¦ä¹ è®¡åˆ’ï¼

ç°åœ¨æ‚¨æ‹¥æœ‰ä¸€ä¸ªå®Œæ•´çš„å¤šAgentæ¡†æ¶ï¼ŒåŒ…æ‹¬ï¼š
- æ ¸å¿ƒAgentå¾ªç¯ï¼ˆReActã€è§„åˆ’ï¼‰
- è®°å¿†ç®¡ç†
- å·¥å…·ç³»ç»Ÿ
- RAGé›†æˆ
- å¤šAgentç¼–æ’
- Agenté€šä¿¡
- å®‰å…¨æŠ¤æ 
- äººæœºåä½œ
- å®Œæ•´å¯è§‚æµ‹æ€§
- ç”Ÿäº§éƒ¨ç½²

**ä¸‹ä¸€æ­¥ï¼š**
- ä½¿ç”¨æ‚¨çš„æ¡†æ¶æ„å»ºå®é™…åº”ç”¨
- è´¡çŒ®å¼€æºAgenté¡¹ç›®
- æ¢ç´¢é«˜çº§ä¸»é¢˜å¦‚Agentå­¦ä¹ 
